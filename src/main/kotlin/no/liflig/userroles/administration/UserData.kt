package no.liflig.userroles.administration

import kotlinx.serialization.Serializable
import no.liflig.logging.field
import no.liflig.publicexception.ErrorCode
import no.liflig.publicexception.PublicException
import no.liflig.userroles.common.serialization.SerializableInstant
import no.liflig.userroles.roles.Role
import no.liflig.userroles.roles.UserRole
import software.amazon.awssdk.services.cognitoidentityprovider.model.AdminCreateUserRequest
import software.amazon.awssdk.services.cognitoidentityprovider.model.AdminUpdateUserAttributesRequest
import software.amazon.awssdk.services.cognitoidentityprovider.model.AttributeType
import software.amazon.awssdk.services.cognitoidentityprovider.model.DeliveryMediumType
import software.amazon.awssdk.services.cognitoidentityprovider.model.UserType

/**
 * User data from Cognito joined with the user's roles from this service.
 *
 * This is the type returned by the List Users endpoint. You can copy this class into your consumer
 * service in order to deserialize responses from User Roles.
 *
 * See https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_UserType.html
 * for more details on the user fields provided by Cognito.
 */
@Serializable
data class UserDataWithRoles(
    /**
     * - Uniquely identifies the user in the Cognito user pool
     * - Also used as the identifier for a user's roles in the User Roles service
     * - Cannot be changed after the user is created
     * - May be human-readable (for example, you may choose to use a user's name before the @ in
     *   their email address as their username, such as "test.testesen")
     * - Min length 1, max length 128
     *
     * If you want a changeable username, you may consider using the `preferred_username` attribute
     * from Cognito instead:
     * https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-attributes.html#user-pool-settings-usernames
     */
    val username: String,
    /**
     * Like [username], this uniquely identifies the user in the Cognito user pool, and cannot be
     * changed. But unlike `username`, this field is generated by Cognito (while `username` is set
     * when creating the user), and appears to be a UUID (we don't validate that it's a UUID here,
     * since Cognito may change this format in the future). You'll typically just use [username],
     * though we still expose this here in case you have a use-case for it.
     *
     * We set this from the `sub` attribute from Cognito, which is the Open-ID Connect field for the
     * user ID.
     */
    val userId: String,
    /**
     * The user's email.
     *
     * Optional attribute in Cognito, though you may configure it to be required on your user pool.
     * If you do that, you can make this non-nullable when copying this class to your consumer
     * service, to assert that you expect this to always be set when deserializing.
     *
     * This object combines the `phone_number` and `phone_number_verified` attributes from Cognito.
     */
    val email: UserEmail?,
    /**
     * The user's phone number.
     *
     * Optional attribute in Cognito, though you may configure it to be required on your user pool.
     * If you do that, you can make this non-nullable when copying this class to your consumer
     * service, to assert that you expect this to always be set when deserializing.
     *
     * This object combines the `phone_number` and `phone_number_verified` attributes from Cognito.
     */
    val phoneNumber: UserPhoneNumber?,
    /**
     * For Cognito, this is one of the following:
     * - `UNCONFIRMED`: User has been created but not confirmed.
     * - `CONFIRMED`: User has been confirmed.
     * - `EXTERNAL_PROVIDER`: User signed in with a third-party IdP.
     * - `RESET_REQUIRED`: User is confirmed, but the user must request a code and reset their
     *   password before they can sign in.
     * - `FORCE_CHANGE_PASSWORD`: The user is confirmed and the user can sign in using a temporary
     *   password, but on first sign-in, the user must change their password to a new value before
     *   doing anything else.
     *
     * See
     * [Cognito docs](https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_UserType.html).
     */
    val userStatus: String,
    /** Whether the user's account is enabled or disabled. */
    val enabled: Boolean,
    /** The date and time the user was created. */
    val createdAt: SerializableInstant,
    /**
     * Additional attributes that you have configured on your Cognito user pool.
     *
     * The OpenID Connect spec (OIDC, used by Cognito) defines a set of standard attributes, such as
     * `name`, which may be included here if they are configured for your user pool. You can also
     * configure custom attributes on your user pool. See
     * [Cognito docs](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-attributes.html#cognito-user-pools-standard-attributes)
     * for more.
     *
     * The standard attributes `email`, `email_verified`, `phone_number`, `phone_number_verified`
     * and `sub` are omitted from this object, since we extract them to the top level of this
     * object.
     *
     * See Cognito docs for possible entries:
     * https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-attributes.html#cognito-user-pools-standard-attributes
     */
    val attributes: Map<String, String>,
    /** The user's roles from the User Roles service. */
    val roles: List<Role>,
) {
  companion object {
    fun fromCognitoAndUserRole(cognitoUser: UserType, userRole: UserRole): UserDataWithRoles {
      val username: String = cognitoUser.username()
      var userId: String? = null

      var email: String? = null
      /** If we don't receive an `email_verified` attribute, assume it's verified. */
      var emailVerified = true

      var phoneNumber: String? = null
      /** If we don't receive a `phone_number_verified` attribute, assume it's verified. */
      var phoneNumberVerified = true

      /** Use [LinkedHashMap] in order to maintain the order of attributes from Cognito. */
      val attributes = LinkedHashMap<String, String>()

      cognitoUser.attributes().forEach { attribute ->
        val key = attribute.name()
        val value = attribute.value()
        /** Extract certain standard attributes, put rest in [attributes] map. */
        when (key) {
          StandardAttribute.SUB.attributeName -> userId = value
          StandardAttribute.EMAIL.attributeName -> email = value
          StandardAttribute.EMAIL_VERIFIED.attributeName -> emailVerified = value == "true"
          StandardAttribute.PHONE_NUMBER.attributeName -> phoneNumber = value
          StandardAttribute.PHONE_NUMBER_VERIFIED.attributeName ->
              phoneNumberVerified = value == "true"
          else -> {
            attributes[key.removePrefix(COGNITO_CUSTOM_ATTRIBUTE_PREFIX)] = value
          }
        }
      }

      if (userId == null) {
        /**
         * According to Cognito, attributes should always include `sub` (user ID):
         * https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-attributes.html#cognito-user-pools-standard-attributes
         */
        throw IllegalStateException(
            "Cognito user '${username}' did not have attribute 'sub' (user ID) set, which we always expect to be present"
        )
      }

      return UserDataWithRoles(
          username = username,
          userId = userId,
          email = email?.let { UserEmail(value = it, verified = emailVerified) },
          phoneNumber =
              phoneNumber?.let { UserPhoneNumber(value = it, verified = phoneNumberVerified) },
          userStatus = cognitoUser.userStatusAsString(),
          enabled = cognitoUser.enabled(),
          createdAt = cognitoUser.userCreateDate(),
          attributes = attributes,
          roles = userRole.roles,
      )
    }
  }
}

@Serializable
data class UserEmail(
    /** The user's email address. Value set from the `email` attribute in Cognito. */
    val value: String,
    /**
     * Whether the user has verified their email address. Value set from the `email_verified`
     * attribute in Cognito.
     */
    val verified: Boolean,
) {
  fun toCognitoAttributes(): List<AttributeType> {
    return listOf(
        createAttribute(StandardAttribute.EMAIL, this.value),
        createAttribute(StandardAttribute.EMAIL_VERIFIED, if (this.verified) "true" else "false"),
    )
  }
}

@Serializable
data class UserPhoneNumber(
    /** The user's phone number. Value set from the `phone_number` attribute in Cognito. */
    val value: String,
    /**
     * Whether the user has verified their phone number. Value set from the `phone_number_verified`
     * attribute in Cognito.
     */
    val verified: Boolean,
) {
  fun toCognitoAttributes(): List<AttributeType> {
    return listOf(
        createAttribute(StandardAttribute.PHONE_NUMBER, this.value),
        createAttribute(
            StandardAttribute.PHONE_NUMBER_VERIFIED,
            if (this.verified) "true" else "false",
        ),
    )
  }
}

/** A subset of the fields from [UserDataWithRoles], used for creating and updating users. */
@Serializable
data class UserUpdateData(
    /** See [UserDataWithRoles.username]. */
    val username: String,
    /** See [UserDataWithRoles.email]. */
    val email: UserEmail?,
    /** See [UserDataWithRoles.phoneNumber]. */
    val phoneNumber: UserPhoneNumber?,
    /**
     * See [UserDataWithRoles.attributes].
     *
     * When updating a user, setting an attribute to a blank value will remove the attribute from
     * Cognito. Unfortunately, this is the only way to remove attributes from Cognito, as just
     * omitting the attribute from this map will make the attribute remain in Cognito.
     *
     * See
     * [Cognito docs for the AdminUpdateUserAttributes operation](https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminUpdateUserAttributes.html).
     */
    val attributes: Map<String, String>,
    /** See [UserDataWithRoles.roles]. */
    val roles: List<Role>,
)

/** @throws PublicException In constructor, if request was invalid. */
@Serializable
data class CreateUserRequest(
    val user: UserUpdateData,
    /**
     * Can be:
     * - Empty (don't send an invitation)
     * - EMAIL (send email invitation, but not SMS)
     * - SMS (send SMS invitation, but not email)
     * - EMAIL and SMS (send both email and SMS invitation)
     */
    val invitationMessages: Set<InvitationMessageType>,
) {
  init {
    /**
     * Cognito enforces that email/phone number must be set when choosing email/SMS as the desired
     * delivery medium. So we enforce that here as well, in order to give a more descriptive error
     * message to the client.
     *
     * See
     * [Cognito docs](https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminCreateUser.html).
     */
    if (invitationMessages.contains(InvitationMessageType.EMAIL) && user.email == null) {
      throw PublicException(
          ErrorCode.BAD_REQUEST,
          publicMessage = "Email must be set for user in order to send email invitation",
          logFields = listOf(field("username", user.username)),
      )
    }

    if (invitationMessages.contains(InvitationMessageType.SMS) && user.phoneNumber == null) {
      throw PublicException(
          ErrorCode.BAD_REQUEST,
          publicMessage = "Phone number must be set for user in order to send SMS invitation",
          logFields = listOf(field("username", user.username)),
      )
    }
  }

  fun toCognitoRequest(userPoolId: String): AdminCreateUserRequest {
    val request = AdminCreateUserRequest.builder()

    request.userPoolId(userPoolId)
    request.username(user.username)

    val attributes = ArrayList<AttributeType>()
    if (user.email != null) {
      attributes.addAll(user.email.toCognitoAttributes())
    }
    if (user.phoneNumber != null) {
      attributes.addAll(user.phoneNumber.toCognitoAttributes())
    }
    for ((name, value) in user.attributes) {
      attributes.add(createAttribute(name, value))
    }
    request.userAttributes(attributes)

    request.desiredDeliveryMediums(invitationMessages.map { it.toCognito() })

    return request.build()
  }
}

enum class InvitationMessageType {
  EMAIL,
  SMS;

  fun toCognito(): DeliveryMediumType {
    return when (this) {
      EMAIL -> DeliveryMediumType.EMAIL
      SMS -> DeliveryMediumType.SMS
    }
  }
}

/**
 * We use a wrapper class for this, in case we want to add more things to this response in the
 * future.
 */
@Serializable data class CreateUserResponse(val user: UserDataWithRoles)

/**
 * We use a wrapper class for this, in case we want to add more things to this request than just
 * [UserUpdateData] in the future.
 */
@Serializable
data class UpdateUserRequest(val user: UserUpdateData) {
  fun toCognitoRequest(userPoolId: String): AdminUpdateUserAttributesRequest {
    val request = AdminUpdateUserAttributesRequest.builder()

    request.userPoolId(userPoolId)
    request.username(user.username)

    val attributes = ArrayList<AttributeType>()
    if (user.email != null && user.email.value.isNotEmpty()) {
      attributes.addAll(user.email.toCognitoAttributes())
    } else {
      /**
       * In order to remove an attribute from Cognito, we must submit the attribute with a blank
       * value. If [UserUpdateData.email] is set to `null`, we do this to make sure any old email is
       * not remaining.
       */
      attributes.add(createAttribute(StandardAttribute.EMAIL, value = ""))
      attributes.add(createAttribute(StandardAttribute.EMAIL_VERIFIED, value = ""))
    }

    if (user.phoneNumber != null && user.phoneNumber.value.isNotEmpty()) {
      attributes.addAll(user.phoneNumber.toCognitoAttributes())
    } else {
      /**
       * In order to remove an attribute from Cognito, we must submit the attribute with a blank
       * value. If [UserUpdateData.phoneNumber] is set to `null`, we do this to make sure any old
       * email is not remaining.
       */
      attributes.add(createAttribute(StandardAttribute.PHONE_NUMBER, value = ""))
      attributes.add(createAttribute(StandardAttribute.PHONE_NUMBER_VERIFIED, value = ""))
    }

    for ((name, value) in user.attributes) {
      attributes.add(createAttribute(name, value))
    }

    request.userAttributes(attributes)

    return request.build()
  }
}
